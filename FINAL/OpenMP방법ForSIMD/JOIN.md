# OpenMP 기반 병렬 블록 해시 조인 알고리즘

## 🎯 알고리즘 개요

**병렬 블록 해시 조인**은 대용량 데이터베이스에서 Customer와 Order 테이블을 효율적으로 조인하는 알고리즘입니다. OpenMP를 활용한 다중 스레드 처리와 블록 단위 메모리 버퍼링, 해시 테이블 기반 탐색을 결합하여 I/O 효율성과 처리 속도를 극대화합니다.

### 핵심 개념
- **블록 단위 처리**: 데이터를 메모리 버퍼에 블록 단위로 로드하여 I/O 효율성 향상
- **해시 기반 조인**: Customer 데이터를 해시 테이블에 인덱싱하여 O(1) 탐색
- **병렬 처리**: OpenMP를 통한 자동 스레딩으로 CPU 활용도 극대화
- **독립 스캔**: 각 스레드가 독립적으로 파일을 읽어 동기화 오버헤드 최소화

## 📊 전체 처리 플로우

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 준비 단계
   ├── 출력 파일 초기화 및 헤더 작성
   ├── Customer 파일 전체 크기 계산 (작업 분배용)
   └── 스레드별 작업 범위 균등 분배

2. 병렬 처리 영역 (OpenMP)
   ├── 각 스레드 독립적 초기화
   │   ├── Customer/Order 파일 리더 생성
   │   ├── 메모리 버퍼 할당 (블록 단위)
   │   ├── 해시 테이블 생성 (체이닝 방식)
   │   └── 결과 저장 버퍼 생성
   │
   ├── 블록 단위 조인 처리 루프
   │   ├── Customer 블록 읽기
   │   │   ├── 지정 범위 내 레코드들을 메모리 버퍼에 로드
   │   │   └── I/O 블록 수 제한으로 효율성 제어
   │   │
   │   ├── 해시 테이블 구축
   │   │   ├── Customer 레코드들을 키로 해싱
   │   │   ├── 충돌 발생 시 체이닝으로 연결
   │   │   └── 버퍼 내 인덱스 정보 저장
   │   │
   │   ├── Order 전체 스캔 및 매칭
   │   │   ├── Order 파일을 처음부터 끝까지 반복 스캔
   │   │   ├── 각 Order 레코드의 키로 해시 테이블 탐색
   │   │   ├── 매칭 성공 시 Customer-Order 쌍 저장
   │   │   └── 블록 단위로 메모리 버퍼링하며 처리
   │   │
   │   └── 블록 정리 및 메모리 관리
   │       └── 해시 테이블 완전 해제 (다음 블록 준비)
   │
   └── 스레드별 리소스 정리
       ├── 남은 결과 데이터 디스크 저장
       └── 파일 핸들러 및 메모리 버퍼 해제

3. 최종 통합 및 마무리
   └── 모든 스레드 결과 합산 및 최종 파일 통계 기록
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

## 🔍 단계별 상세 설명

### 1️⃣ 준비 단계

**목적**: 조인 작업을 위한 환경 설정과 작업 분배

- **출력 파일 초기화**: 결과 저장 파일 생성 및 헤더 정보 기록
- **데이터 크기 파악**: Customer 파일의 총 레코드 수 계산
- **작업 분배**: 총 레코드를 스레드 수만큼 균등하게 분할

**예시**: 150,000개 레코드를 2개 스레드로 분배하면 각 스레드는 75,000개씩 담당

### 2️⃣ 병렬 처리 영역

**핵심**: OpenMP의 `parallel for` 지시문을 통해 자동 스레딩

#### 각 스레드의 초기화 작업
- **파일 접근**: 각 스레드가 독립적으로 Customer와 Order 파일을 열음
- **메모리 준비**: 블록 단위 데이터 처리를 위한 버퍼 공간 확보
- **해시 테이블**: 빠른 키 탐색을 위한 자료구조 초기화
- **결과 버퍼**: 매칭 결과를 임시 저장할 공간 준비

#### 블록 단위 조인 처리

##### Customer 블록 읽기
**방식**: 라인 단위로 순차 읽기 + 블록 경계 제어
- 메모리 버퍼가 가득 찰 때까지 Customer 레코드를 읽어 저장
- I/O 블록 수 제한으로 디스크 접근 효율성 제어
- 스레드 담당 범위를 벗어나면 중단

##### 해시 테이블 구축
**역할**: Customer 데이터를 빠른 탐색이 가능한 형태로 변환
- 각 Customer 레코드의 키를 해시 함수로 변환
- 해시 값에 해당하는 버킷에 노드 삽입
- 동일 버킷 내 충돌 시 연결 리스트로 체이닝
- 버퍼 내 위치 정보 함께 저장

##### Order 스캔 및 조인 수행
**전략**: 전체 Order 데이터를 해시 테이블과 매칭
- Order 파일을 처음부터 끝까지 반복 읽기
- 각 Order 레코드의 고객 키로 해시 테이블 탐색
- 매칭되는 Customer가 있으면 결과로 저장
- 블록 단위로 메모리 버퍼링하며 효율성 유지

##### 블록 정리
**중요성**: 메모리 누수 방지와 다음 블록 준비
- 현재 블록의 해시 테이블 완전 해제
- 동적 할당된 노드들 모두 메모리 반납
- 다음 Customer 블록 처리를 위한 초기화

### 3️⃣ 마무리 단계

**통합**: 각 스레드의 결과를 하나의 최종 결과로 합산
- OpenMP의 `reduction` 절이 자동으로 총합 계산
- 결과 파일에 최종 통계 정보 추가 기록

## 🗂️ 해시 테이블 동작 원리

### 기본 구조
해시 테이블은 **배열 + 연결 리스트** 형태의 자료구조입니다.

```
버킷 0: [Node] → [Node] → NULL
버킷 1: [Node] → NULL
버킷 2: NULL
...
버킷 N: [Node] → [Node] → [Node] → NULL
```

### 키 처리 과정
1. **해싱**: `고객키 % 테이블크기`로 버킷 번호 계산
2. **삽입**: 해당 버킷의 맨 앞에 새 노드 연결
3. **탐색**: 버킷 내 연결 리스트를 순차 검색
4. **매칭**: 키 값 일치 시 버퍼 인덱스로 실제 데이터 접근

### 메모리 관리 전략
- **블록 단위 수명**: 각 Customer 블록마다 새로 생성/파괴
- **동적 할당**: 필요한 만큼만 노드 생성
- **완전 정리**: 블록 종료 시 모든 노드 메모리 해제

## 💾 I/O 처리 방식

### 라인 단위 읽기 전략
- **읽기 단위**: 한 줄(레코드)씩 읽기
- **안전성**: 레코드 경계 보장 (줄바꿈 기준)
- **파싱 용이**: "|" 구분자 기반 구조화 데이터 처리

### 블록 경계 모니터링
- **I/O 카운팅**: 파일 포인터 위치로 블록 넘김 감지
- **제한 제어**: `buffer_blocks` 파라미터로 I/O 양 조절
- **효율성**: OS 캐싱 메커니즘 자동 활용

## ⚡ 병렬 처리 아키텍처

### 독립 스캔 방식
- **Customer 분할**: 각 스레드가 자신의 데이터 범위만 처리
- **Order 공유**: 모든 스레드가 전체 Order 데이터를 독립적으로 읽음
- **동기화 최소화**: 파일 I/O는 독립적, 결과 저장만 보호

### OpenMP 활용
- **자동 스레딩**: 컴파일러가 최적 스레드 수 결정
- **결과 통합**: `reduction`으로 자동 합산
- **단순성**: 명시적 스레드 관리 불필요

## 📈 성능 특징

### 측정 데이터 (참고)
- **실행 환경**: 2스레드, 블록 제한 100
- **처리량**: 150만 개 매칭 결과
- **I/O 효율**: 131회 블록 접근
- **실행 시간**: 약 2.5초

### 확장성
- **CPU 스케일링**: 스레드 수 증가 시 성능 선형 향상
- **메모리 효율**: 블록 단위 처리로 메모리 사용 최적화
- **I/O 트레이드오프**: 블록 크기 조절로 메모리 vs I/O 균형 조정

## 🎖️ 알고리즘 장점

### 1. 메모리 효율성
대용량 데이터도 블록 단위로 나누어 처리하여 메모리 사용량을 일정하게 유지

### 2. I/O 최적화
버퍼링과 블록 단위 제어로 디스크 접근을 효율적으로 관리

### 3. 확장성
스레드 수와 버퍼 크기를 파라미터로 조절하여 다양한 환경에 적응

### 4. 구현 단순성
OpenMP의 고수준 추상화로 복잡한 병렬 프로그래밍을 간단하게 구현

## 🎓 결론

이 병렬 블록 해시 조인 알고리즘은 **대용량 데이터베이스 조인**의 효율적인 해결책입니다. 블록 단위 메모리 관리, 해시 기반 빠른 탐색, OpenMP를 활용한 병렬 처리를 통해 기존의 중첩 루프 조인보다 월등한 성능을 제공합니다.

특히, **독립 스캔 아키텍처**는 구현의 단순성과 성능의 균형을 잘 맞추어 교육용 및 실무용 모두에 적합한 알고리즘입니다.